var marqdoujAzureMaps;(()=>{"use strict";var e={d:(t,o)=>{for(var a in o)e.o(o,a)&&!e.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:o[a]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{Configuration:()=>l,Layers:()=>p,MapFactory:()=>c,Maps:()=>i});const o=atlas;var a,r,n;!function(e){let t;!function(e){e[e.Trace=0]="Trace",e[e.Debug=1]="Debug",e[e.Information=2]="Information",e[e.Warn=3]="Warn",e[e.Error=4]="Error",e[e.Critical=5]="Critical",e[e.None=6]="None"}(t=e.LogLevel||(e.LogLevel={})),e.currentLevel=t.Information,e.logMessage=function(o,a,r,...n){if(a<e.currentLevel)return;const s=`${function(e){return`Map with Id '${e}'`}(o)} ${r}`;switch(a){case t.Trace:console.trace(s,...n);break;case t.Debug:console.debug(s,...n);break;case t.Information:console.info(s,...n);break;case t.Warn:console.warn(s,...n);break;case t.Error:console.error(s,...n);break;case t.Critical:console.error(`CRITICAL: ${s}`,...n)}}}(a||(a={}));class s{static isEmptyOrNull(e){return""===e?.trim()}static isNotEmptyOrNull(e){return!this.isEmptyOrNull(e)}}!function(e){let t,o,a,r,n,s,i,c,l,p,d;!function(e){e.NotifyMapEvent="NotifyMapEvent",e.NotifyMapEventConfig="NotifyMapEventConfig",e.NotifyMapEventData="NotifyMapEventData",e.NotifyMapEventError="NotifyMapEventError",e.NotifyMapEventLayer="NotifyMapEventLayer",e.NotifyMapEventMouse="NotifyMapEventMouse",e.NotifyMapEventReady="NotifyMapEventReady",e.NotifyMapEventSource="NotifyMapEventSource",e.NotifyMapEventStyle="NotifyMapEventStyle",e.NotifyMapEventTouch="NotifyMapEventTouch"}(t=e.EventNotifications||(e.EventNotifications={})),function(e){e.BoxZoomEnd="boxzoomend",e.BoxZoomStart="boxzoomstart",e.Drag="drag",e.DragEnd="dragend",e.DragStart="dragstart",e.Idle="idle",e.Load="load",e.Move="move",e.MoveEnd="moveend",e.MoveStart="movestart",e.Pitch="pitch",e.PitchEnd="pitchend",e.PitchStart="pitchstart",e.Render="render",e.Resize="resize",e.Rotate="rotate",e.RotateEnd="rotateend",e.RotateStart="rotatestart",e.TokenAcquired="tokenacquired",e.Zoom="zoom",e.ZoomEnd="zoomend",e.ZoomStart="zoomstart"}(o=e.MapEventGeneral||(e.MapEventGeneral={})),function(e){e.MapConfigChanged="mapconfigurationchanged"}(a=e.MapEventConfig||(e.MapEventConfig={})),function(e){e.Data="data",e.SourceData="sourcedata",e.StyleData="styledata"}(r=e.MapEventData||(e.MapEventData={})),function(e){e.LayerAdded="layeradded",e.LayerRemoved="layerremoved"}(n=e.MapEventLayer||(e.MapEventLayer={})),function(e){e.Click="click",e.ContextMenu="contextmenu",e.DblClick="dblclick",e.MouseDown="mousedown",e.MouseMove="mousemove",e.MouseOut="mouseout",e.MouseOver="mouseover",e.MouseUp="mouseup"}(s=e.MapEventMouse||(e.MapEventMouse={})),function(e){e.Wheel="wheel"}(i=e.MapEventWheel||(e.MapEventWheel={})),function(e){e.SourceAdded="sourceadded",e.SourceRemoved="sourceremoved"}(c=e.MapEventSource||(e.MapEventSource={})),function(e){e.StyleImageMissing="styleimagemissing",e.StyleSelected="styleselected"}(l=e.MapEventStyle||(e.MapEventStyle={})),function(e){e.StyleChanged="stylechanged"}(p=e.MapEventStyleChanged||(e.MapEventStyleChanged={})),function(e){e.TouchCancel="touchcancel",e.TouchEnd="touchend",e.TouchMove="touchmove",e.TouchStart="touchstart"}(d=e.MapEventTouch||(e.MapEventTouch={}))}(r||(r={}));class i{static addControls(e,t){const r=c.getMap(e);r&&t.forEach(t=>{let n=null;switch(t.type.toLowerCase()){case"compass":n=new o.control.CompassControl(t.options);break;case"fullscreen":n=new o.control.FullscreenControl(t.options);break;case"pitch":n=new o.control.PitchControl(t.options);break;case"scale":n=new o.control.ScaleControl(t.options);break;case"style":n=new o.control.StyleControl(t.options);break;case"zoom":n=new o.control.ZoomControl(t.options);break;default:a.logMessage(e,a.LogLevel.Warn,`- addControls: control type '${t.type}' is not supported.`)}n&&(n.jsInterop={id:t.id,interopId:t.interopId,type:t.type,options:t.controlOptions},r.controls.add(n,t.controlOptions))})}static getControls(e){const t=c.getMap(e);if(!t)return;const o=t.controls.getControls(),a=[];return o.filter(e=>this.#e(e)).forEach(e=>{const t=e,o={id:t.jsInterop.id,interopId:t.jsInterop.interopId,type:t.jsInterop.type,options:t.jsInterop.options};a.push(o)}),a}static removeControls(e,t){const o=c.getMap(e);o&&o.controls.getControls().filter(e=>this.#e(e)).forEach(e=>{const a=e;t.find(e=>e.id===a.jsInterop.id||e.interopId===a.jsInterop.interopId)&&o.controls.remove(e)})}static clearDatasource(e,t){const o=c.getMap(e);if(!o)return;const r=o.sources.getById(t);r&&(r.clear(),a.logMessage(e,a.LogLevel.Debug,`- clearDatasource: datasource with ID '${t}' was cleared.`))}static createDatasource(e,t){const r=c.getMap(e);if(!r)return;if(r.sources.getById(t.id))return void a.logMessage(e,a.LogLevel.Warn,`- createDatasource: datasource with ID '${t.id}' already exists.`);const n=new o.source.DataSource(t.id,t.options);r.sources.add(n),t.url&&n.importDataFromUrl(t.url)}static removeDatasource(e,t){const o=c.getMap(e);if(!o)return;const r=o.sources.getById(t);r&&(o.sources.remove(r),a.logMessage(e,a.LogLevel.Debug,`- removeDatasource: datasource with ID '${t}' was removed.`))}static#e(e){return e&&null!=e.jsInterop}}class c{static#t=new Map;static getAuthTokenCallback;static createMap(e,t,r,n,s){if(a.currentLevel=r.logLevel??a.LogLevel.Information,this.#t.has(t))return void a.logMessage(t,a.LogLevel.Warn,"Map already exists.");r.inDevelopment&&a.logMessage(t,a.LogLevel.Trace,"Settings-MapOptions:",r.options);const c=this.#o(r.authOptions,r.options),l=new o.Map(t,c);this.#t.set(t,l),a.logMessage(t,a.LogLevel.Debug,"was created."),s&&i.addControls(t,s),this.#a(e,t,n)}static getMap(e){const t=this.#t.get(e);return t||a.logMessage(e,a.LogLevel.Debug,"was not found."),t}static removeMap(e){this.#t.delete(e)&&a.logMessage(e,a.LogLevel.Debug,"was removed")}static#o(e,t){let o={};return t&&(t.camera?o={...o,...t.camera}:t.cameraBounds&&(o={...o,...t.cameraBounds}),t.service&&(o={...o,...t.service}),t.style&&(o={...o,...t.style}),t.userInteraction&&(o={...o,...t.userInteraction})),o.authOptions=e,o.authOptions.getToken=this.getAuthTokenCallback,o}static#a(e,t,o){const n=this.getMap(t);n?(o??=[],n.events.addOnce("ready",s=>{n.events.add("error",n=>{a.logMessage(t,a.LogLevel.Error,`Map error: ${n.error.message}`,n.error),o.includes("error")&&e.invokeMethodAsync(r.EventNotifications.NotifyMapEventError,{mapId:t,type:"error",payload:{message:n.error.message,name:n.error.name,stack:n.error.stack,cause:n.error.cause}})}),Object.values(r.MapEventGeneral).filter(e=>o.includes(e)).forEach(o=>{n.events.add(o,()=>{e.invokeMethodAsync(r.EventNotifications.NotifyMapEvent,{mapId:t,type:o})})}),Object.values(r.MapEventConfig).filter(e=>o.includes(e)).forEach(o=>{n.events.add(o,a=>{let n={mapId:t,type:o,payload:a};e.invokeMethodAsync(r.EventNotifications.NotifyMapEventConfig,n)})}),Object.values(r.MapEventData).filter(e=>o.includes(e)).forEach(o=>{n.events.add(o,a=>{let n={mapId:t,type:o,payload:{dataType:a.dataType,isSourceLoaded:a.isSourceLoaded,source:a.source?.getId(),sourceDataType:a.sourceDataType,tile:a.tile}};e.invokeMethodAsync(r.EventNotifications.NotifyMapEventData,n)})}),Object.values(r.MapEventLayer).filter(e=>o.includes(e)).forEach(o=>{n.events.add(o,a=>{let n={mapId:t,type:o,payload:{id:a.getId()}};e.invokeMethodAsync(r.EventNotifications.NotifyMapEventLayer,n)})}),Object.values(r.MapEventMouse).filter(e=>o.includes(e)).forEach(o=>{n.events.add(o,n=>{try{const s=[];n.shapes.filter(e=>this.#r(e)).forEach(e=>{s.push(this.#n(e))}),n.shapes.filter(e=>this.#s(e)).forEach(e=>{s.push(this.#i(e))}),n.shapes.length!=s.length&&a.logMessage(t,a.LogLevel.Warn,`MouseEvent. Event shapes count [${n.shapes.length}] and processed shapes count [${s.length}] does not match.`);let i={mapId:t,type:o,payload:{layerId:n.layerId,pixel:n.pixel,position:n.position,shapes:s}};e.invokeMethodAsync(r.EventNotifications.NotifyMapEventMouse,i)}catch(e){a.logMessage(t,a.LogLevel.Error,`Error processing mouse event: ${e}`)}})}),Object.values(r.MapEventSource).filter(e=>o.includes(e)).forEach(o=>{n.events.add(o,a=>{let n={mapId:t,type:o,payload:{id:a.getId()}};e.invokeMethodAsync(r.EventNotifications.NotifyMapEventSource,n)})}),Object.values(r.MapEventStyle).filter(e=>o.includes(e)).forEach(o=>{n.events.add(o,a=>{let n={mapId:t,type:o,payload:{style:a}};e.invokeMethodAsync(r.EventNotifications.NotifyMapEventStyle,n)})}),Object.values(r.MapEventStyleChanged).filter(e=>o.includes(e)).forEach(o=>{n.events.add(o,a=>{let n={mapId:t,type:o,payload:{style:a.style}};e.invokeMethodAsync(r.EventNotifications.NotifyMapEventStyle,n)})}),Object.values(r.MapEventTouch).filter(e=>o.includes(e)).forEach(o=>{n.events.add(o,a=>{const n=[];a.shapes.forEach(e=>{n.push(this.#i(e))});let s={mapId:t,type:o,payload:{pixel:a.pixel,pixels:a.pixels,position:a.position,positions:a.positions,shapes:n,layerId:a.layerId}};e.invokeMethodAsync(r.EventNotifications.NotifyMapEventTouch,s)})}),Object.values(r.MapEventWheel).filter(e=>o.includes(e)).forEach(o=>{n.events.add(o,a=>{let n={mapId:t,type:o,payload:{type:a.type}};e.invokeMethodAsync(r.EventNotifications.NotifyMapEvent,n)})}),e.invokeMethodAsync(r.EventNotifications.NotifyMapEventReady,{mapId:t,type:"ready"})})):a.logMessage(t,a.LogLevel.Error,"Cannot build events. Map not found.")}static#r(e){return e&&"Feature"===e.type}static#s(e){return e&&null!=e.getType}static#n(e){return{id:e.id?.toString(),type:e.geometry.type,bbox:e.bbox,source:"feature",properties:e.properties}}static#i(e){return{id:e.getId()?.toString(),type:e.getType(),bbox:e.getBounds(),source:"shape",properties:e.getProperties()}}}class l{static getCamera(e){const t=c.getMap(e);if(t)return t.getCamera()}static setCamera(e,t){const o=c.getMap(e);if(!o)return;let a=this.#c(t);o.setCamera(a)}static getMapOptions(e){const t=c.getMap(e);if(t)return{mapCamera:t.getCamera(),service:t.getServiceOptions(),style:t.getStyle(),userInteraction:t.getUserInteraction()}}static setMapOptions(e,t){const o=c.getMap(e);if(!o)return;console.debug("Setting map options - before:",t);let a=this.#c(t.camera);console.debug("Setting map options - after:",a),o.setCamera(a),t.service&&o.setServiceOptions(t.service),t.style&&o.setStyle(t.style),t.userInteraction&&o.setUserInteraction(t.userInteraction)}static getServiceOptions(e){const t=c.getMap(e);if(t)return t.getServiceOptions()}static setServiceOptions(e,t){const o=c.getMap(e);o&&o.setServiceOptions(t)}static getStyle(e){const t=c.getMap(e);if(t)return t.getStyle()}static setStyle(e,t){const o=c.getMap(e);o&&o.setStyle(t)}static getUserInteraction(e){const t=c.getMap(e);if(t)return t.getUserInteraction()}static setUserInteraction(e,t){const o=c.getMap(e);o&&o.setUserInteraction(t)}static#c(e){let t={};return e.camera?t={...e.camera,...e.animation}:e.cameraBounds&&(t={...e.cameraBounds,...e.animation}),t}}class p{static createLayer(e,t,r){const n=c.getMap(e);if(!n)return;if(s.isEmptyOrNull(t.type))return void a.logMessage(e,a.LogLevel.Error,"- CreateLayer: layer type is missing");const i=t.id;if(s.isNotEmptyOrNull(i)&&n.layers.getLayerById(i))return void a.logMessage(e,a.LogLevel.Error,`- CreateLayer: layer already exists where ID=${i}`);let l;if(r){if(l=new o.source.DataSource(r.id,r.options),!l)return void a.logMessage(e,a.LogLevel.Error,"- CreateLayer: Unable to create datasource.",r);n.sources.add(l),s.isNotEmptyOrNull(r.url)&&l.importDataFromUrl(r.url)}else if(l=n.sources.getById(t.sourceId),!l)return void a.logMessage(e,a.LogLevel.Error,`- CreateLayer: Unable to find datasource where ID=${t.sourceId}.`);const p=t.options||{};switch(p.jsInterop={layerid:i},t.type){case"Bubble":n.layers.add(new o.layer.BubbleLayer(l,i,p),t.before);break;case"HeatMap":n.layers.add(new o.layer.HeatMapLayer(l,i,p),t.before);break;case"Image":n.layers.add(new o.layer.ImageLayer(p,i),t.before);break;case"Line":n.layers.add(new o.layer.LineLayer(l,i,p),t.before);break;case"Polygon":n.layers.add(new o.layer.PolygonLayer(l,i,p),t.before);break;case"PolygonExtrusion":n.layers.add(new o.layer.PolygonExtrusionLayer(l,i,p),t.before);break;case"Symbol":n.layers.add(new o.layer.SymbolLayer(l,i,p),t.before);break;case"Tile":n.layers.add(new o.layer.TileLayer(p,i),t.before);break;default:a.logMessage(e,a.LogLevel.Warn,`- CreateLayer: layer type '${t.type}' is not supported.`)}}static removeLayer(e,t){const o=c.getMap(e);if(!o)return;const r=o.layers.getLayerById(t);r&&(o.layers.remove(r),a.logMessage(e,a.LogLevel.Debug,`- CreateLayer:- layer with id '${t}' was removed.`))}static addMapFeature(e,t,r,s){const i=c.getMap(e);if(!i)return;const l=i.sources.getById(r);if(s&&t.id){const e=l.getShapeById(t.id);e&&l.remove(e)}let p;switch(t.geometry.type.toLowerCase()){case n.Point:p=new o.data.Point(t.geometry.coordinates);break;case n.MultiPoint:p=new o.data.MultiPoint(t.geometry.coordinates,t.bbox);break;case n.LineString:p=new o.data.LineString(t.geometry.coordinates,t.bbox);break;case n.Polygon:p=new o.data.Polygon(t.geometry.coordinates,t.bbox)}if(!p)return void a.logMessage(e,a.LogLevel.Error,`- adding feature error: geometry type '${t.geometry.type}' not supported`);const d=new o.data.Feature(p,t.properties,t.id);if(t.asShape){const e=new o.Shape(d);l.add(e)}else l.add(d)}}!function(e){e.Point="point",e.MultiPoint="multipoint",e.LineString="linestring",e.MultiLineString="multilinestring",e.Polygon="polygon",e.MultiPolygon="multipolygon"}(n||(n={})),marqdoujAzureMaps=t})();